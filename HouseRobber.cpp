class Solution {
public:
    int rob(vector<int>& nums) {
        //一般来说，给定一个规则，让我们求任意状态下的解，都是用动态规划。这里的规则是劫匪不能同时抢劫相邻的屋子，即我们在累加时，只有两种选择：
        //1.如果选择了抢劫上一个屋子，那么就不能抢劫当前的屋子，所以最大收益就是抢劫上一个屋子的收益;2.如果选择抢劫当前屋子，就不能抢劫上一个屋子，所以最大收益是到上一个屋子的上一个屋子为止的最大收益，加上当前屋子里有的钱.
        //dp[i]表示当前i下的最大收益，递推公式：dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        //本来我们是要用一个dp数组来保存之前的结果的。但实际上我们只需要上一次和上上次的结果，所以可以用两个变量就行了
        if (nums.size() <= 1) {
            return nums.size() == 0 ? 0 :nums[0];
        }
        int a = nums[0]; //上一次的最大收益
        int b = max(nums[0], nums[1]); //当前的最大收益
        for (int i = 2; i < nums.size(); i++) {
            int tmp = b;
            b = max(a + nums[i], b);
            a = tmp;
        }
        return b;
    }
};